package temp_dev;

import java.util.*;
import java.io.*;

// 수정 필요
public class Boj {
	private static int[] group;
	
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int n = Integer.parseInt(st.nextToken());
		int m = Integer.parseInt(st.nextToken());
		group = new int[n + 1];
		for (int i = 0 ; i < n+1; i++) {
			group[i] = i;
		}
		
		st = new StringTokenizer(br.readLine());
		boolean[] know = new boolean[n+1];
		int t = Integer.parseInt(st.nextToken());
		if(t == 0) {
			System.out.println(m);
			return;
			
		} else {
			int com1 = Integer.parseInt(st.nextToken());
			know[com1] = true;
			
			while(st.hasMoreTokens()) {
				int com2 = Integer.parseInt(st.nextToken());
				know[com2] = true;
				
				union(com1, com2);
			}
		}
		
		List<int[]> party = new ArrayList<>();
		for (int i = 0; i < m; i++) {
			st = new StringTokenizer(br.readLine());
			
			int tot = Integer.parseInt(st.nextToken());
			int[] tmp = new int[tot];

			for (int j = 0; j < tot; j++) {
				tmp[j] = Integer.parseInt(st.nextToken());
				union(tmp[0], tmp[j]);
			}
			
			party.add(tmp);
		}
		
		int cnt = m;
		for (int[] p : party) {
			for (int x : p) {
				if (know[find(x)]) cnt--; break;
			}
		}
		
		System.out.print(cnt);
	}
	
	
	public static void union(int x, int y) {
		int xx = find(x);
		int yy = find(y);
		
		if(xx != yy) {
			group[y] = xx;
		}
	}
	
	
	public static int find(int x) {
		if (group[x] == x) {
			return x;
			
		} else {
			return find(group[x]);
		}
	}
}

/* * Union-Find 알고리즘 
 *   서로소 집합(Dis) 알고리즘
 *   여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 이 노드가 같은 그래프에 속하는지 판별하는 알고리즘
*/
